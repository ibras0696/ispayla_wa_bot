# Обзор проекта и структура

Этот файл — шпаргалка для разработчика: что где лежит, как работают сценарии, как добавлять фичи и где искать баги.

## Карта репозитория
- `app/bot_runner.py` — точка входа; создаёт бот через `app/bot/runner.py`.
- `app/bot/runner.py` — регистрирует все хендлеры (incoming/outgoing) и инициализирует БД.
- `app/bot/handlers/` — бизнес-логика:
  - `basic.py` — `/start`, `баланс`, общий fallback (форма продаж, вызовы sell/buy). Обрабатывает входящие/исходящие события, фильтрует дубликаты по `idMessage`.
  - `menu.py` — главное меню (reply-кнопки + текстовые триггеры).
  - `profile.py` — текст профиля.
  - `sell.py` — подменю продажи, «Мои объявления», детали по номеру/ID.
  - `buy.py` — каталог/поиск/фильтры/пагинация/избранное, карточка с фото.
- `app/bot/services/`:
  - `state.py` — обёртки над async CRUD (Postgres), выборка объявлений/брендов/избранного, получение фото, фасады `db_runner.run`.
  - `forms.py` — мастер продажи (FSM в памяти процесса).
  - `guard.py` — whitelist, извлечение `chatId`/`sender`.
- `app/bot/ui/` — кнопки (`buttons.py`), тексты (`texts.py`).
- `app/database/` — SQLAlchemy модели (`models.py`), CRUD в `crude/` (объявления, фото, бренды, избранное, модерация и пр.).
- `docs/` — `journal.md` (changelog), `PROJECT_TZ.md` (план), `PROJECT_OVERVIEW.md` (этот файл).
- `media/uploads` — локальное хранилище фото объявлений.

## Сценарии (как сейчас работает)
- **Меню**: команда `меню` или кнопка → «Профиль/Продажа/Покупка».
- **Продажа**:
  - «Разместить объявление»: мастер (заголовок → описание → цена → марка → год → пробег → VIN → фото до 3 шт.) → запись в БД (активно), фото в `media/uploads`.
  - «Мои объявления»: список последних + детали по номеру списка или `ID#`.
- **Покупка**:
  - Каталог активных объявлений, фильтры (цена/год/пробег/марка), пагинация кнопками «⬅️/➡️/Обновить».
  - Поиск по названию (кнопка/текст «Поиск авто»), вывод до N, открытие по номеру/ID.
  - Избранное (просмотр, добавление текстом «в избранное»), карточка с фото (первое).
- **Профиль/баланс**: простые ответы из таблицы `users`.

## Поток сообщений и роутинг
- Маршрутизатор (`runner.py`) вешает хендлеры на incoming/outgoing события. Основные текстовые триггеры: `/start`, `баланс`, `меню`, `профиль/продажа/покупка`.
- Всё остальное попадает в `basic.handle_fallback`: если активна форма продажи — продолжает её; иначе пробует `handle_sell_text` → `handle_buy_text` → автоответ.
- Для outgoing сообщений от собственного `wid` fallback игнорирует событие (чтобы не отвечать самому себе).
- Whitelist: `ALLOWED_SENDERS` в `.env` (значения `79...@c.us` или без домена). Не whitelisted — игнор.

## Архитектурные ноты / паттерны
- **Слои**: хендлеры → сервисы (`state.py`) → CRUD → БД. Хендлеры не ходят напрямую в CRUD.
- **Фасады sync/async**: `state.py` оборачивает async CRUD через `DBRunner.run`. Можно заменить на чистый async-хендлер, если уйдём от `run`.
- **FSM/состояния**: форма продажи и фильтры — in-memory (персист в файл для фильтров). План — Redis как стор состояния.
- **UI-константы**: кнопки/тексты вынесены в `ui/`, чтобы не смешивать данные и логику.
- **Кэш выдачи**: `_LAST_CATALOG`/`_LAST_DETAILS` в `buy.py` для открытия карточек по номеру без повторной выборки. Сброс очищает кэши.
- **Идемпотентность**: fallback кэширует `idMessage`, игнорирует собственные outgoing — защита от дублированных событий Green API.
- **Guard**: единый `guard_sender`/whitelist перед любой логикой.

## Данные и стейт
- Postgres: объявления, фото, бренды, пользователи, избранное. Async CRUD (`crude/*`), синхронные фасады (`state.py`).
- Фото: файлы в `media/uploads`, пути в `ad_images`.
- Состояния мастера продажи и фильтров покупки — в памяти процесса; фильтры дополнительно сериализуются в `state_filters.json` (в планах перенести в Redis).

## Как добавить/поменять функциональность
- **Новый хендлер**: создайте файл в `app/bot/handlers/`, экспорт при необходимости в `__init__.py`, зарегистрируйте в `runner.py` через `bot.router.message(...)`/`outgoing_message(...)`.
- **Новая кнопка/текст**: `ui/buttons.py` + `ui/texts.py`, используйте в хендлере.
- **Новая операция с БД**: добавьте метод в `crude/*.py`, обёртку в `state.py` (async + фасад `db_runner.run`).
- **Новый мастер**: по аналогии с `forms.py`, хранение стейта — пока в памяти (лучше Redis).
- **Каталог/фильтры**: основная логика в `handlers/buy.py` (`_render_filtered`, `_update_*_filter`, `_extract_public_id`, `_build_ad_detail`).

## Запуск и отладка
1. Настроить `.env`: `ID_INSTANCE`, `API_TOKEN`, `DOMAIN/base_url`, креды Postgres, `ALLOWED_SENDERS`.
2. Запуск: `docker compose up -d --build` (или `make upb`).
3. Логи: `docker compose logs -f bot` (смотреть INFO/DEBUG из хендлеров).
4. Проверка: отправить «меню» → открыть меню, «Покупка» → «Все объявления», затем цифру.

## Частые проблемы и проверки
- **Карточка по номеру не открывается**: убедитесь, что сообщение дошло до `handle_buy_text` (ищите в логах INFO "Запрос детали объявления"). Если нет — сообщение попало в outgoing от своего wid → игнор; или нет кэша `_LAST_CATALOG` для данного chatId. Каталог надо отправлять в этом чате перед цифрой.
- **Спам при сбросе/показе**: fallback теперь отсекает свои outgoing, сообщения кэшируются по `idMessage`; `_reset_filters` чистит `_LAST_*` и `_SEARCH_WAIT`.
- **Нет объявлений после фильтров**: команда «сброс» или снова «покупка» обнуляет фильтры и кэши.
- **Whitelist**: если чат не в `ALLOWED_SENDERS`, бот молчит.

## Что делать дальше (MVP+)
- Перенести фильтры/формы в Redis, убрать `state_filters.json`.
- Карточки покупки: кнопки «В избранное/Убрать», отправка всех фото.
- Модерация объявлений, валидации полей, лимиты фото.
- Alembic миграции, тесты (хендлеры, фильтры, избранное), S3 для фото.

## Мини-инструкции по задачам
- **Добавить новую команду**: маршрут в `runner.py`, логика в новом/существующем хендлере, текст/кнопки в `ui/`.
- **Новый атрибут объявления**: поле в `models.py`, метод в `crude/add.py`/`state.py`, учесть в мастере продажи и карточке.
- **Отладить поиск**: смотрите логи INFO в `handlers/buy.py`, проверяйте `_LAST_CATALOG` и активность объявлений (`is_active=True`).
